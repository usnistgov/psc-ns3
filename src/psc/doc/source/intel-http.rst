.. include:: replace.txt

++++++++++++++++
Intel HTTP Model
++++++++++++++++

The classes ``ns3::psc::IntelHttpClient``, ``ns3::psc::IntelHttpHeader``,
and ``ns3::psc::IntelHttpServer`` implement a configurable HTTP model.


This model is an implementation of the model defined in this Intel paper:
`A NEW TRAFFIC MODEL FOR CURRENT USER WEB BROWSING BEHAVIOR <https://blogs.intel.com/wp-content/mt-content/com/research/HTTP%20Traffic%20Model_v1%201%20white%20paper.pdf>`_

-----------------
Model Description
-----------------

The implementation is provided in the following files:

* ``src/psc/model/intel-http-client.{h,cc}`` The client application
* ``src/psc/model/intel-http-header.{h,cc}`` The header used in packets
* ``src/psc/model/intel-http-server.{h,cc}`` The server application
* ``src/psc/helper/intel-http-helper.{h,cc}`` The helper

An example may be found in: ``src/psc/examples/example-intel-http.cc``.

This model represents a configurable HTTP client and
corresponding HTTP server. The model is based on analysis of logs from ten 
HTTP Squid proxy caches in the 2007 timeframe (HTTP/1.0 and HTTP/1.1 clients).
The log data included requests from 60,000 clients.

In the following description, names containing an 'Rvs' suffix denote names
of an ``ns3::RandomVariableStream`` object. Unless otherwise specified, sizes
are in Bytes.

The HTTP client generates a request size from ``RequestSizeRvs``
and sends a request to the server defined by ``RemoteAddress``
and ``RemotePort``.

The server receives the request and generates a size
for the response page from ``HtmlSizeRvs`` as well as
the number of embedded objects referenced on generated page.
The 'page' is then transferred back to the client.

Once the client receives the page, it will wait
a time defined by ``ParseTimeRvs`` to 'parse' the received page.
Once parsed, the model goes over each embedded object and
checks against the probability that it is cached defined by ``CacheThreshold``.

If the embedded object is not cached the client will generate another request
size (from ``RequestSizeRvs``). The server generates Inter-Arrival Time for
the embedded object from ``EmbeddedObjectIatRvs`` and waits that time,
generates a size for the object from ``EmbeddedObjectSizeRvs`` and sends that
response. The client then parses that response.

Once all embedded objects have been received, the client will read the
completed page for an amount of time defined by ``ReadTimeRvs``.

All packets carry an application header, the ``IntelHttpHeader``. This 
header has 3 fields. First, a ``Type`` field describing whether the packet 
refers to an HTML object (the main object) or an embedded object. Next, a 
numeric field (``NumberOfObjects``) with variable meaning, depending on the 
type of the packet:

* In an HTML Object Request, the field is meaningless.
* In an HTML Object Response, the field details how many embedded objects
  are associated with the HTML Object served.
* In an Embedded Object Request, the field indicates the sequence number of
  the embedded object requested within the list of embedded objects for the
  last HTML object requested.
* In an Embedded Object Response, the field indicates the sequence number of
  the embedded object served within the list of embedded objects for the
  last HTML object requested.

Finally, a ``Payload Size`` field, with the size of the Request message 
(for Requests) or the size of the object served (for Responses). 
  

Limitations
+++++++++++

The ``ns3::psc::IntelHttpServer`` may only serve one
``ns3::psc::IntelHttpClient`` at a time.

This restriction may be circumvented by installing several
``ns3::psc::IntelHttpServer`` applications on one Node on different ports.
See the ``MultipleServerClients`` example in
``src/psc/examples/example-intel-http.cc`` for a demonstration of one server
Node serving many client nodes.


Model Flow Diagram
++++++++++++++++++
.. figure:: figures/intel-http.png
   :alt: Diagram representing the flow of the Intel HTTP model


Attributes
++++++++++


IntelHttpClient
---------------

* ``RemoteAddress``:
    The address of the server to communicate with.
* ``RemotePort``:
    The port on the server to send to.
* ``CacheThreshold``:
    Threshold to decide if an embedded object is cached or not.
    If the value generated by ``CacheRvs`` is less than or equal to this value,
    then the object was cached and will not be requested.
* ``CacheRvs``:
    Stream that generates the value compared with the ``CacheThreshold`` to
    decide if an embedded object is cached or not.
    Should generate a value between 0 and 1.
* ``RequestSizeRvs``:
    Random Variable Stream to generate the size of the requests.
* ``ParseTimeRvs``:
    Random Variable Stream to generate the time
    required to parse a downloaded file.
    Bound by ``ParseTimeLowBound`` and ``ParseTimeHighBound``.
* ``ReadTimeRvs``:
    Random Variable Stream to generate the time
    spent reading a page after it has been downloaded.
    Bound by ``ReadTimeLowBound`` and ``ReadTimeHighBound``.
* ``SocketBufferSize``:
    Size in Bytes of the socket send and receive buffers.

IntelHttpHeader
---------------

``IntelHttpHeader`` exposes no attributes.


IntelHttpServer
---------------

* ``Port``:
    Port on which we listen for incoming packets.
* ``HtmlSizeRvs``:
    Random Variable Stream to generate the size of the HTML pages.
    Bound by ``HtmlSizeLowBound`` and ``HtmlSizeHighBound``.
* ``EmbeddedObjectAmountRvs``:
    Random Variable Stream to generate the amount of embedded objects.
    Bound by ``EmbeddedObjectAmountLowBound`` and
    ``EmbeddedObjectAmountHighBound``.
* ``EmbeddedObjectIatRvs``:
    Random Variable Stream to generate the IAT of embedded objects.
    Bound by ``EmbeddedObjectIatLowBound`` and ``EmbeddedObjectIatHighBound``.
* ``EmbeddedObjectSizeRvs``:
    Random Variable Stream to generate the size of the embedded objects.
    ``EmbeddedObjectSizeLowBound`` and ``EmbeddedObjectSizeHighBound``.


Trace sources
+++++++++++++

IntelHttpClient
---------------

* ``Rx``:
    General trace for receiving an application packet of any kind. If the 
    application packet was fragmented, only one line will be traced when the
    last fragment is received. This trace source is invoked for all application
    packets received (i.e., all the Responses). This source makes available the 
    received application packet (with the ``IntelHttpHeader``) and the address 
    of the node that sent the packet. As the ``IntelHttpHeader`` is included, 
    trace sinks can make use of the ``RequestType`` and ``NumberOfObjects`` 
    fields to match packet entries with the corresponding transmission trace.
* ``RxMainObject``:
    Trace for when an application-level packet containing a main object is fully 
    received. This source is invoked once for each Response with an HTML object 
    (main object). If the Response message was fragmented, the trace will be 
    invoked only when the final fragment has been received. This source makes 
    available the received application packet (with the ``IntelHttpHeader``) and
    the address of the node that sent the packet. As the ``IntelHttpHeader`` is 
    included, trace sinks can make use of the ``RequestType`` and
    ``NumberOfObjects`` fields to match packet entries with the corresponding
    transmission trace.
 
* ``RxEmbeddedObject``:
    Trace for when an application-level packet containing an embedded object is 
    fully received. This source is invoked once for each Response for an 
    embedded object. If the Response message was fragmented, the trace will be 
    invoked only when the final fragment has been received. This source makes 
    available the received application packet (with the ``IntelHttpHeader``) and
    the address of the node that sent the packet. As the ``IntelHttpHeader`` is 
    included, trace sinks can make use of the ``RequestType`` and
    ``NumberOfObjects`` fields to match packet entries with the corresponding 
    transmission trace.
 

* ``Tx``:
    General trace for sending an application packet of any kind. This trace 
    source is invoked for all application packets sent (i.e., all the Requests). 
    This source makes available the application packet sent (with the 
    ``IntelHttpHeader``). As the ``IntelHttpHeader`` is included, trace sinks 
    can make use of the ``RequestType`` and ``NumberOfObjects`` fields to 
    match packet entries with the corresponding reception trace.

* ``TxRequestMainObject``:
    Trace for when an application-level packet containing a Request for 
    a main object is sent.
    This source is invoked once for each Request with an HTML object 
    (main object). This source makes available the transmitted application 
    packet (with the ``IntelHttpHeader``). As the ``IntelHttpHeader`` is 
    included, trace sinks can make use of the ``RequestType`` and 
    ``NumberOfObjects`` fields to 
    match packet entries with the corresponding reception trace.
 
    
* ``TxRequestEmbeddedObject``:
    Trace for when an application-level packet containing a Request for an
    embedded object is
    sent. This source is invoked once for each Request with an embedded object.
    This source makes available the received application packet 
    (with the ``IntelHttpHeader``). As the ``IntelHttpHeader`` is included, 
    trace sinks can make use of the ``RequestType`` and ``NumberOfObjects``
    fields to match packet entries with the corresponding reception trace.
 

* ``CacheHit``:
    Trace called when object on a page was cached and does not need to be
    transmitted.
* ``CacheMiss``:
    Trace called when object on a page was not cached and needs to be requested.

IntelHttpServer
---------------------------------

* ``Rx``:
    General trace for receiving an application packet of any kind. If the 
    application packet was fragmented, only one line will be traced when the
    last fragment is received. This trace source is invoked for all application
    packets received (i.e., all the Requests). This source makes available the 
    received application packet (with the ``IntelHttpHeader``) and the address 
    of the node that sent the packet. As the ``IntelHttpHeader`` is included, 
    trace sinks can make use of the ``RequestType`` and ``NumberOfObjects`` 
    fields to match packet entries with the corresponding transmission trace.
* ``RxRequestMainObject``:
    Trace for when an application-level packet containing a Request for a 
    main object is fully 
    received. This source is invoked once for each Request with an HTML object 
    (main object). If the request message was fragmented, the trace will be 
    invoked only when the final fragment has been received. This source makes 
    available the received application packet (with the ``IntelHttpHeader``) and
    the address of the node that sent the packet. As the ``IntelHttpHeader`` is 
    included, trace sinks can make use of the ``RequestType`` and
    ``NumberOfObjects`` fields to match packet entries with the corresponding
    transmission trace.
* ``RxRequestEmbeddedObject``:
    Trace for when an application-level packet containing a Request for an
    embedded object is 
    fully received. This source is invoked once for each Request for an 
    embedded object. If the Request message was fragmented, the trace will be 
    invoked only when the final fragment has been received. This source makes 
    available the received application packet (with the ``IntelHttpHeader``) and
    the address of the node that sent the packet. As the ``IntelHttpHeader`` is 
    included, trace sinks can make use of the ``RequestType`` and
    ``NumberOfObjects`` fields to match packet entries with the corresponding 
    transmission trace.

* ``Tx``:
    General trace for sending an application packet of any kind. This trace 
    source is invoked for all application packets sent (i.e., all the 
    Responses). 
    This source makes available the application packet sent (with the 
    ``IntelHttpHeader``). As the ``IntelHttpHeader`` is included, trace sinks 
    can make use of the ``RequestType`` and ``NumberOfObjects`` fields to match 
    packet entries with the corresponding reception trace.
* ``TxMainObject``:
    Trace for when an application-level packet containing a main object is sent.
    This source is invoked once for each Response with an HTML object 
    (main object). This source makes available the transmitted application 
    packet (with the ``IntelHttpHeader``). As the ``IntelHttpHeader`` is 
    included, trace sinks can make use of the ``RequestType`` and 
    ``NumberOfObjects`` fields to match 
    packet entries with the corresponding reception trace.
 
* ``TxEmbeddedObject``:
    Trace for when an application-level packet containing an embedded object is
    sent. This source is invoked once for each Response with an embedded object.
    This source makes available the received application packet 
    (with the ``IntelHttpHeader``). As the ``IntelHttpHeader`` is included, 
    trace sinks can make use of the ``RequestType`` and ``NumberOfObjects`` 
    fields to match packet entries with the corresponding reception trace.
 

-----
Tests
-----

The following tests have been written for this model
and may be found in ``src/psc/test/intel-http-model-test.cc``:

* ``IntelHttpTestCaseAllCacheHits``:
    Test with a perfect `CacheThreshold` that no embedded objects
    are requested/transmitted.
* ``IntelHttpTestCaseAllCacheMisses``:
    Test with a `CacheThreshold` of 0 that all embedded
    are requested/transmitted.
* ``IntelHttpTestCaseCacheTotal``:
    Verify the total number of cache hits/misses matches the total embedded
    objects. Also verifies the 'objectsLeft' parameter passed to the
    `CacheHit` and `CacheMiss` traces.
* ``IntelHttpTestCaseEmbeddedObjectSequence``:
    Tests the, given a constant `EmbeddedObjectIatRvs`, embedded objects are
    both requested and transmitted in order.
* ``IntelHttpTestCaseEventOrder``:
    Test that each event defined by the *Model Flow Diagram* happens in
    the correct order.
* ``IntelHttpTestCaseHeaderContent``:
    Verify the request types in each possible packet are of the correct type.
    As well as the embedded object count.
* ``IntelHttpTestCaseIpv6``:
    Verify the model still works when providing IPv6 addresses
    instead of IPv4 ones.
* ``IntelHttpTestCaseObjectInterArrival``:
    Verify that, after receiving a request for an embedded object, the server
    will wait the time from the `EmbeddedObjectIatRvs` before responding.
* ``IntelHttpTestCaseParseTime``:
    Test the the client waits the time from the `RequestSizeRvs` before
    continuing.
* ``IntelHttpTestCaseReadTime``:
    Test that the client waits the time from `ReadTimeRvs` before requesting
    another main object.
* ``IntelHttpTestCaseTxRxCountSizes``:
    Verify the specific transmit (i.e., `TxMainObject`) and receive
    (i.e., `RxEmbeddedObject`) traces are called the same number of times
    as the general ones (`Tx`/`Rx`). Also verifies the packets of each
    type are of the correct size.

-----
Usage
-----

A simple usage example is provided in:
``src/psc/examples/example-intel-http.cc``.

The following attributes are exposed for users to change but are set to
defaults that match the Intel cache logs, so in practice, most users will
not change these values: 

* ``HtmlSizeRvs``, ``HtmlSizeLowBound``, and ``HtmlSizeHighBound``.
* ``EmbeddedObjectAmountRvs``, ``EmbeddedObjectAmountLowBound``, 
    and ``EmbeddedObjectAmountHighBound``.
* ``EmbeddedObjectIatRvs``, ``EmbeddedObjectIatLowBound``, 
    and ``EmbeddedObjectIatHighBound``.
* ``EmbeddedObjectSizeRvs``, ``EmbeddedObjectSizeLowBound``, 
    and ``EmbeddedObjectSizeHighBound``.
* ``RequestSizeRvs``.
* ``ParseTimeRvs``, ``ParseTimeLowBound``, and ``ParseTimeHighBound``.
* ``ReadTimeRvs``, ``ReadTimeLowBound``, and ``ReadTimeHighBound``.

On the other hand the following attributes are more likely to be changed 
by users: 

* ``RemoteAddress``, ``RemotePort``, ``Port``: 
    Besides the basic configuration
    match between client and server regarding the connection address and port, 
    as the server model only supports a single client, when configuring scenarios
    with multiple clients special attention must be paid to ensure there are 
    enough servers for all the clients, and that each of them use a unique 
    connection string (address and port).
* ``CacheThreshold``, and ``CacheRvs``: 
    Intel's whitepaper defines the cache 
    mechanism but it does not specify the parameters (threshold or 
    distribution to use). Based on this, the model provides default values for 
    both parameters (``CacheThreshold`` and ``CacheRvs``) that are functional 
    (a 16 % cache hit ratio on the client fits a small cache size with diverse 
    (i.e., multiple different sites) browsing). However, these values may not 
    fit all use cases (e.g., local caches in corporate environments where 
    browsing is restricted to intranet pages that share the same structure, 
    images, etc. can easily reach 90 % hit ratios). 
* ``SocketBufferSize``: 
    The models configure a socket buffer size set to the
    maximum size by default (2,147,483,647 Bytes), to avoid the case where the 
    server generates embedded objects with sizes larger than the available socket 
    size. The maximum buffer size allows us to avoid dropping these packets and 
    distorting the distribution configured by the user (or proposed by Intel). 
    However, depending on the area of study and the interests of the users running 
    the simulations, this may lead to unrealistic results, so the parameter is 
    available for configuration as needed (with the caveat that the user will
    need to ensure that the distribution chosen for the Embedded Object sizes
    does not generate values that may overflow the buffer).

