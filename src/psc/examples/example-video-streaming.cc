/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * NIST-developed software is provided by NIST as a public service. You may use,
 * copy and distribute copies of the software in any medium, provided that you
 * keep intact this entire notice. You may improve,modify and create derivative
 * works of the software or any portion of the software, and you may copy and
 * distribute such modifications or works. Modified works should carry a notice
 * stating that you changed the software and should note the date and nature of
 * any such change. Please explicitly acknowledge the National Institute of
 * Standards and Technology as the source of the software.
 *
 * NIST-developed software is expressly provided "AS IS." NIST MAKES NO
 * WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY OPERATION OF
 * LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT
 * AND DATA ACCURACY. NIST NEITHER REPRESENTS NOR WARRANTS THAT THE
 * OPERATION OF THE SOFTWARE WILL BE UNINTERRUPTED OR ERROR-FREE, OR THAT
 * ANY DEFECTS WILL BE CORRECTED. NIST DOES NOT WARRANT OR MAKE ANY
 * REPRESENTATIONS REGARDING THE USE OF THE SOFTWARE OR THE RESULTS THEREOF,
 * INCLUDING BUT NOT LIMITED TO THE CORRECTNESS, ACCURACY, RELIABILITY,
 * OR USEFULNESS OF THE SOFTWARE.
 *
 * You are solely responsible for determining the appropriateness of using and
 * distributing the software and you assume all risks associated with its use,
 * including but not limited to the risks and costs of program errors,
 * compliance with applicable laws, damage to or loss of data, programs or
 * equipment, and the unavailability or interruption of operation. This
 * software is not intended to be used in any situation where a failure could
 * cause risk of injury or damage to property. The software developed by NIST
 * employees is not subject to copyright protection within the United States.
 */

#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/internet-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/applications-module.h"
#include "ns3/psc-module.h"

using namespace ns3;
using namespace psc;

/**
 * In this example, we have 2 nodes connected via a point-to-point link.
 * One node is acting as a server and the other node as a client streaming
 * videos from the server starting 10 s after the simulation start.
 *
 * The video streaming model will load data distributions for packet size and
 * inter-packet interval according to the 'distribution' parameter. These
 * pre-configured distributions are loaded from src/psc/model/psc-video-streaming-distributions.cc.
 * These distributions have been generated by collecting packet information at
 * the application level, which means it is possible to generate very large
 * packets. Depending on the complexity of the streaming application, these
 * large packets may be fragmented using fixed size fragments (regardless of
 * the network technology used to transmit them), or a negotiation with the
 * streaming client may take place to dynamically set the maximum fragment size.
 * This example uses a default maximum fragment size of 1500 Bytes (which is
 * the behavior on ffmpeg version 4 doing RTP streaming), but this value can
 * be modified to better match our needs using the 'maxUdpDatagramSize' parameter.
 *
 * Another configurable aspect of the model is the 'Boost' period. Many video
 * streaming applications will send an initial burst of packets with a data rate
 * larger than needed for the streaming, so that the client can build a buffer
 * to account for variations of delay. This behavior is called in the model
 * 'boost' period, and is controlled through two parameters. 'boostLength' sets
 * the amount of packets that will make up the 'boost' period. 'boostPercentile'
 * sets the percentile of the distributions (both size and inter-packet interval)
 * from which values will be collected during the 'boost' period. When the
 * application starts, the data distributions for packet size and interval will
 * be truncated and (effectively) scaled at the boostPercentile point so that, 
 * during the boost period, packet size will be drawn from a set of larger values, 
 * and inter-packet interval will be drawn from the portion of the CDF with shorter 
 * intervals. For example, if 'boostPercentile' is '90' and 'boostLength' is '50', 
 * during the 'boost' period the model will only generate values of packet size with 
 * a cumulative probability of 90 % or  higher, and only values of inter-packet interval
 * or 10 % or lower will be selected. After 50 packets have been generated in this
 * manner, the model will use the full distributions for new packet sizes and
 * inter-packet intervals.
 *
 * There are five parameters to this scenario:
 * - distribution: type of video, which can be '720p-bright' (default), '720p-dark', '1080p-bright', or '1080p-dark'
 * - duration: video streaming duration in seconds (default: 600)
 * - boostLength: length (in packets transmitted) of the initial boost period (default: 50)
 * - boostPercentile: percentile to calculate packet boost [0, 100] (default: 90)
 * - maxUdpDatagramSize: maximum UDP packet size [12, 65500] (default: 1500)
 */

NS_LOG_COMPONENT_DEFINE ("ExampleVideoStreaming");

void
TxPacketTrace (Ptr<OutputStreamWrapper> stream, std::string context, Ptr<const Packet> p)
{
  std::ostringstream oss;
  *stream->GetStream () << Simulator::Now ().GetSeconds () << "\t" << context << "\t" << p->GetSize () << std::endl;
}

void
RxPacketTrace (Ptr<OutputStreamWrapper> stream, std::string context, Ptr<const Packet> p, const Address &srcAddrs)
{
  std::ostringstream oss;
  *stream->GetStream () << Simulator::Now ().GetSeconds () << "\t" << context << "\t" << p->GetSize () << std::endl;
}

int
main (int argc, char *argv[])
{
  //Define scenario parameters
  std::string distribution = "720p-bright";
  Time        duration = Seconds (600);
  uint32_t    boostLength = 50;
  double      boostPercentile = 90;
  uint16_t    maxUdpDatagramSize = 1500;

  CommandLine cmd;
  cmd.AddValue ("distribution", "Built-in data distribution to use", distribution);
  cmd.AddValue ("duration", "Duration of the video streaming (s)", duration);
  cmd.AddValue ("boostLength", "Length of the initial boost, in packets transmitted", boostLength);
  cmd.AddValue ("boostPercentile", "Percentile from which the size and intervals are pulled from during the initial boost", boostPercentile);
  cmd.AddValue ("maxUdpDatagramSize", "Maximum size (in Bytes) of the UDP datagrams generated by the application", maxUdpDatagramSize);
  cmd.Parse (argc, argv);

  if (distribution.compare ("720p-bright") != 0
      && distribution.compare ("720p-dark") != 0
      && distribution.compare ("1080p-bright") != 0
      && distribution.compare ("1080p-dark") != 0)
    {
      std::cerr << "Error, supported distributions are '720p-bright', '720p-dark', '1080p-bright', and '1080p-dark', but user requested '" << distribution << "'." << std::endl;
      return -1;
    }

  if (boostPercentile < 0 || boostPercentile > 100)
    {
      std::cerr << "Error, percentile value must be between 0 and 100 (inclusive), but user requested " << boostPercentile << "." << std::endl;
      return -1;
    }

  if (maxUdpDatagramSize < 12 || maxUdpDatagramSize > 65500)
    {
      std::cerr << "Error, maximum UDP datagram size must be between 12 and 65500 (inclusive), but user requested " << maxUdpDatagramSize << "." << std::endl;
      return -1;
    }

  Time simTime = duration + Seconds (10);

  NS_LOG_DEBUG ("Distribution = " << distribution);
  NS_LOG_DEBUG ("Simulation time = " << simTime);

  //Creates the two nodes
  NodeContainer nodes;
  nodes.Create (2);

  //Creates the link and attach to the nodes
  PointToPointHelper pointToPoint;
  pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("100Gbps"));
  pointToPoint.SetChannelAttribute ("Delay", StringValue ("1ms"));
  NetDeviceContainer devices;
  devices = pointToPoint.Install (nodes);

  //Configure IP stack
  InternetStackHelper stack;
  stack.Install (nodes);
  Ipv4AddressHelper address;
  address.SetBase ("10.0.0.0", "255.255.255.0");
  Ipv4InterfaceContainer interfaces = address.Assign (devices);

  //Configure applications
  ApplicationContainer apps;

  Ptr <PscVideoStreaming> streamingServer = CreateObject <PscVideoStreaming> ();
  apps.Add (streamingServer);

  // Attributes
  streamingServer->SetAttribute ("ReceiverAddress", AddressValue (interfaces.GetAddress (1)));
  streamingServer->SetAttribute ("ReceiverPort", UintegerValue (5554));
  streamingServer->SetAttribute ("Distribution", StringValue (distribution));

  streamingServer->SetAttribute ("BoostLengthPacketCount", UintegerValue (boostLength));
  streamingServer->SetAttribute ("BoostPercentile", DoubleValue (boostPercentile));

  streamingServer->SetAttribute ("MaxUdpDatagramSize", UintegerValue (maxUdpDatagramSize));

  nodes.Get (0)->AddApplication (streamingServer);

  PacketSinkHelper packetSinkHelper ("ns3::UdpSocketFactory", InetSocketAddress (Ipv4Address::GetAny (), 5554));
  apps.Add (packetSinkHelper.Install (nodes.Get (1)));

  apps.Start (Seconds (10));
  apps.Stop (simTime);

  //Traces
  AsciiTraceHelper ascii;
  std::ostringstream oss;
  Ptr<OutputStreamWrapper> packetOutputStream = ascii.CreateFileStream ("VideoPacketTrace.txt");
  *packetOutputStream->GetStream () << "time(sec)\ttx/rx\tPktSize(bytes)" << std::endl;

  oss.str ("tx\t");
  apps.Get (0)->TraceConnect ("Tx", oss.str (), MakeBoundCallback (&TxPacketTrace, packetOutputStream));
  oss.str ("rx\t");
  apps.Get (1)->TraceConnect ("Rx", oss.str (), MakeBoundCallback (&RxPacketTrace, packetOutputStream));

  Simulator::Run ();
  Simulator::Destroy ();

  return 0;
}
